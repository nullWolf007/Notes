# 常用算法技巧

## 一、字符串匹配

* 详情请查看[**字符串匹配**](https://github.com/nullWolf007/Notes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.md)

## 二、背包类问题

* 常用解决方法：动态规划，递归
* 详情请查看[**背包问题**](https://github.com/nullWolf007/Notes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.md)

## 三、哈希表存储

### 1.例题(简单)

* 查看原题请点击[**leetcode-存在重复元素**](https://leetcode-cn.com/problems/contains-duplicate/)

![存在重复元素](https://github.com/nullWolf007/images/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.png)

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> hashSet = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            if (hashSet.contains(nums[i])) {
                return true;
            } else {
                hashSet.add(nums[i]);
            }
        }
        return false;
    }
}
```

## 深度优先搜索(DFS)

* 查看例题请点击[回溯算法例题](https://github.com/nullWolf007/Notes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%94%E5%A4%A7%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3.md#%E5%9B%9B%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95)

## 广度优先搜索(BFS)

### 1.例题(中等--BFS)

### 3.例题(困难--BFS+限制条件)

* 查看原题请点击[**leetcode--穿过迷宫的最少移动次数**](https://leetcode-cn.com/problems/minimum-moves-to-reach-target-with-rotations/)

![贪吃蛇](https://github.com/nullWolf007/images/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/%E8%B4%AA%E5%90%83%E8%9B%87.png)

* 思路：采用BFS的方式去处理，利用queue进行存储，每次往里面放数据，然后取数据。然后如果能够到达终点，返回步数。由于相等于层序搜素，所以第一个到达终点的就是。
* 层序遍历 通过每次遍历queue的size次 就会pull本层的数据 只保留下一层的数据；见代码while(size>0)
* 代码

```java
class Solution {
   public static void main(String[] args) {
        Solution solution = new Solution();
        int[][] grid = {
                {0, 0, 0, 0, 0, 1},
                {1, 1, 0, 0, 1, 0},
                {0, 0, 0, 0, 1, 1},
                {0, 0, 1, 0, 1, 0},
                {0, 1, 1, 0, 0, 0},
                {0, 1, 1, 0, 0, 0}};
        System.out.println(solution.minimumMoves(grid));
    }
    
    public int minimumMoves(int[][] grid) {
        int n = grid.length;

        LinkedList<Data> queue = new LinkedList<>();
        queue.add(new Data(0, 0, 0, 1, 0, Data.H));
        //使用首和尾和一起作为 经过的标识
        boolean[][][][] visited = new boolean[n][n][n][n];
        visited[0][0][0][1] = true;
        //四个方向 右、下、顺旋转90度、逆旋转90度
        int[][] dirs = new int[][]{{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};
        while (!queue.isEmpty()) {
            int size = queue.size();
            //每次把本层的数据 全部都的取出
            //对于该层的每个数据 查找满足条件的下一层数据 放入queue中
            //通过该方式 实现每一层每一层的搜索
            while (size > 0) {
                size--;
                Data curr = queue.pollFirst();
                //找到该点 下一层满足的所有数据
                for (int i = 0; i < dirs.length; i++) {
                    int[] dir = dirs[i];

                    if (i == 2)
                        if (curr.orientation == Data.V || curr.x1 == n - 1 || grid[curr.x1 + 1][curr.y1] == 1 || grid[curr.x2 + 1][curr.y2] == 1)
                            continue;

                    if (i == 3)
                        if (curr.orientation == Data.H || curr.y1 == n - 1 || grid[curr.x1][curr.y1 + 1] == 1 || grid[curr.x2][curr.y2 + 1] == 1)
                            continue;

                    int nx1 = curr.x1 + dir[0];
                    int ny1 = curr.y1 + dir[1];
                    int nx2 = curr.x2 + dir[2];
                    int ny2 = curr.y2 + dir[3];

                    if (nx1 < 0 || nx1 >= n || ny1 < 0 || ny1 >= n)
                        continue;

                    if (nx2 < 0 || nx2 >= n || ny2 < 0 || ny2 >= n)
                        continue;

                    if (grid[nx1][ny1] == 1 || grid[nx2][ny2] == 1)
                        continue;

                    if (visited[nx1][ny1][nx2][ny2])
                        continue;

                    if (nx1 == n - 1 && ny1 == n - 2 && nx2 == n - 1 && ny2 == n - 1)
                        return curr.step + 1;

                    visited[nx1][ny1][nx2][ny2] = true;
                    //只有旋转可以改变方向 i为3或4表示旋转
                    queue.add(new Data(nx1, ny1, nx2, ny2, curr.step + 1, i >= 2 ? curr.orientation * -1 : curr.orientation));
                }
            }
        }
        return -1;
    }
}

class Data {
    //H表示横着
    public static final int H = -1;
    //V表示竖着
    public static final int V = 1;

    public int x1, y1, x2, y2;//首位坐标
    public int step;//步数
    public int orientation;//方向

    public Data(int x1, int y1, int x2, int y2, int step, int orientation) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.step = step;
        this.orientation = orientation;
    }
}
```

