[TOC]

# 常见的算法

### 参看文章链接

* [五大常用算法之一：分治算法](https://www.cnblogs.com/xsyfl/p/6921687.html)

### 参考例题链接

* [领扣官网题库](https://leetcode-cn.com/problemset/all/)



## 暴力破解

## 回溯算法

## 深度优先搜索(DFS)

## 广度优先搜索(BFS)

## 递归

## 迭代

## 分治算法

### 1.概念

分治算法：字面上就是分而治之，就是把一个复杂的问题分解成两个或多个相同或相似的问题，再把子问题分成更小的问题.....直到最后的小问题可以简单的求出解，原问题的解就是子问题的解的合并

### 2.思路

* 分解：将要解决的问题划分成若干规模较小的同类问题
* 求解：当子问题划分的足够小的时候，用简单的方法去解决
* 合并：按原问题的要求，将子问题的解逐层合并构成原问题的解

### 3.典型问题

* 合并排序
* 快速排序
* 二分搜索

### 4.分治和递归的关系

* 分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法
* 但是也存在 非递归的分治法

## 动态规划

## 贪心算法

### 1.概念

贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。
贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

### 2.思路

* 建立数学模型来描述问题
* 把求解的问题分成若干个子问题
* 对每个子问题进行求解，得到子问题的局部最优解
* 把字问题的局部最优解和成原问题的解

### 3.存在的问题

* 不能保证求得的最后解是最佳的
* 不能用来求最大值或最小值的问题
* 只能求满足某些约束条件的可行解的范围

### 4.前提

* 局部最优策略能够导致全局最优解

### 5.例题（简单）

![分发饼干](https://github.com/nullWolf007/images/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.png)

```java
class Solution {
    //贪心算法 每次都找胃口最小的孩子和可以满足的最小的饼干
    public int findContentChildren(int[] g, int[] s) {
        //对胃口和饼干 排下序
        Arrays.sort(g);
        Arrays.sort(s);
        int i = 0;
        int j = 0;
        while (i < g.length && j < s.length) {
            if (g[i] <= s[j]) {
                //可以满足
                i++;
                j++;
            } else {//不能满足 说明饼干太小了
                j++;
            }
        }
        return i;
    }
}
```











