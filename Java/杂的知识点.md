# 杂的知识点

## 计算机的组成部分
* 中央处理器(CPU)
* 内存(RAM主存)
* 存储设备(磁盘,光盘,U盘等)
* 输入设备(鼠标,键盘等)
* 输出设备(显示器,打印机等)
* 通信设备调制解调器,网卡等)

## 操作系统的主要任务
* 控制和监视系统的活动
* 分配和调配系统的资源
* 调度操作

## 多道程序设计，多线程，多处理
* 多道程序设计：多个程序共享CPU同时运行
* 多线程：单个程序同时执行多个任务
* 多处理：多个处理器共同并行执行子任务

# JDK，IDE
* JDK：用于运行和开发Java程序的软件
* IDE：快速开发程序的集成开发环境

# 软件开发过程
* 需求规范
* 系统分析
* 系统设计
* 实现
* 测试
* 部署
* 维护

# 注意循环的差一错误

# 在命令行中的输入输出重定向
* 输入重定向 java name < demo.text
* 输出重定向 java name > demo.txt
* 输入输出重定向 java name <input.txt> output.txt

# 编码方式
* 自顶向下
* 自底向上

# 方法抽象和逐步求精

# 数组
* elementType[] arrayRefVar = new elementType[arraySize]; **包含了 声明一个数组变量；创建数组；将数组引用赋值给变量 三个步骤**
* 数组初始化语法中不使用操作符new，使用数组初始化语法时，必须将声明，创建和初始化数组都放在同一条语句。
* foreach循环(遍历整个数组)
```java
for(elemType element : arrayName){
    //element
}
```

# 方法
* 在方法传递参数的时候，基本数据类型和引用数据类型是不一样的，基本数据类型传递的是值，而引用类型传递的是引用，所以基本数据类型只会在方法中改变，而引用数据类型在方法内外都会发生改变
* 可变长参数列表：在方法声明中，指定类型后紧跟省略号(...)。在方法中只能指定一个可变长参数，并且该参数必须是最后一个参数，任何常规参数都必须在他的前面。

# 二维数组
* 二维数组中的每一行本身就是一个数组，因此各行的长度就可以不同，这样的数组叫做锯齿数组
* 使用语法new int[][]创建数组时，必指定第一个下标，如new int[5][]，否则时错误的

# 对象和类
* 为啥可以使用Math.power()等方法，而对于我们自己定义的类的方法不能这样调用。因为Math类中的所有方法的方法都是用static定义的静态方法，但是我们自己定义的类是实例方法，是非静态的，所以我们必须使用对象来调用，而不能使用类名调用
* 引用类型的数据域如果没有初始化，系统会给他默认值。而局部变量如果没有初始化，调用他的时候会报错NullPointerException
* 静态变量被类中的所有对象共享，静态方法不能访问类中的实例成员；静态方法和静态数据可以通过引用变量或者他们的类名来调用

# 继承和多态
* Java中是不允许多重继承的，只能是单一继承
* 一般情况下，最好能为每个类提供一个无参构造方法，以便于对该类进行扩展，同时避免错误
* 仅当实例方法是可以访问的，它才能被覆盖。因为私有方法在它的类本身以外是不能被访问的，所以它不能被覆盖。如果子类中定义的方法在父类中是私有的，那么这两个方法完全没有关系
* 与实例方法一样，静态方法也能被继承，但是静态方法不能被覆盖。如果父类定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将会被隐藏。可以使用语法：父类名.静态方法名调用隐藏的静态方法
* @Override是重写标注，对于被标注的方法必须重写父类的一个方法
* 多态意味着父类型的变量可以引用子类型的对象
* 动态绑定：方法可以沿着继承链的多个类实现，此时到底调用的是那个方法就是动态的，找到所对应的最特殊的方法就是需要被调用的方法
* instanceof语法：name1 instanceof name2如果name1是name2的类型或者子类型就为true
* 子类可以重写他的父类的protected方法，并将它的可见性改为public，但是子类不能削弱父类中定义的方法的可访问性。例如：如果一个方法在父类中定义为public，那么子类必须是public
* 被final修饰的类和方法都不能被扩展(也就是继承重写啥的)

# 异常处理和文本I/O
* try catch finally 其中finally中的语句一定会被执行的
* throw方法如果被调用的话，他会调用catch代码块，在catch代码块执行完毕后，执行catch后面的代码
* 声明异常的关键字是throws，抛出异常的关键字是throw
* 在catch块中异常被指定的顺序是非常重要的，如果父类的catch块出现在子类的catch之前，就会导致编译错误
* 使用的条件：当必须处理不可预料的错误状况时



