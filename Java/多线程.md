# 多线程

## 线程
* **线程调用run和start方法的区别**
> 线程对象调用run方法不开启线程，仅仅是对象调用方法。线程对象调用start方法开启线程，并让jvm调用run方法再开启的线程中执行（start会开启线程，run不会开启线程）
* **实现线程的两种方法**
> 继承extends Thread，对象调用start方法
> 实现implements Runnable接口，创建Thread类对象，构造方法传递Runnable接口实现类，再调用Thread对象的start方法
* **线程的状态**

  ![图片](https://github.com/nullWolf007/Notes/raw/master/Java/Image/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.JPG)

> NEW：新建对象就是新建状态，比如new Thread()

> RUNNABLE:对象调用start方法，进入该状态

> TERMINATED：run()结束或者调用stop方法，进入该状态

> BLOCKED:阻塞状态，CPU繁忙或者同步锁

> WAITING:调用wait方法

> TIMEWAITING：调用sleep方法

## 线程池
* **概念**
> 容纳多个线程的容器，其中线程可以反复使用，省去频繁创建线程对象的操作，无需反复创建线程，大大减少开销
* **原理**
> 创建一个ArrayList<Thread>，创建多个线程到集合中，使用remove和add方法
* **使用**
> Executors类：线程池创建工厂类

> Callable接口：补充run方法没有返回值，run不能抛出异常
```java
//创建指定线程个数的对象，返回ExecutorService接口的实现类
ExecutorService es = Executors.newFixedThreadPool(10);
//调用submit(Runnable)方法提交线程执行任务
es.submit(new Runnable() {
	
	@Override
	public void run() {
		// TODO Auto-generated method stub	
		
	}
});
//返回Future接口的实现类
Future<String> f = es.submit(new Callable<String>() {

	@Override
	public String call() throws Exception {
		// TODO Auto-generated method stub
		return null;
	}
});
//使用Future的get方法获取返回值
try {
	System.out.println(f.get());
} catch (InterruptedException e) {
	// TODO Auto-generated catch block
	e.printStackTrace();
} catch (ExecutionException e) {
	// TODO Auto-generated catch block
	e.printStackTrace();
}


//销毁线程池,一般不使用
es.shutdown();
```

## 多线程并发
* **多线程数据源是同一个，并且线程使数据源改变**，多线程并发时如何解决存在的安全隐患
```java
public class ManyThreads {

	public static void main(String[] args) {
		Ticket t = new Ticket();
		Thread t0 = new Thread(t);
		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);

		t0.start();
		t1.start();
		t2.start();
	}
}

class Ticket implements Runnable {

	private int ticketNum = 10;

	@Override
	public void run() {
		// TODO Auto-generated method stub
		while (ticketNum > 0) {
			System.out.println(Thread.currentThread().getName() + " 出售第" + ticketNum-- + "张票");
		}
	}

}
```
> 安全性分析:假设此时ticketNum为1，此时运行t0线程，通过while判断之后，t0被堵塞，之后运行t1线程，必然通过判断，输出1张票，假设此时t0线程由阻塞状态转变为运行状态，则出现输出出售0张票，存在隐患

> 安全性分析：由于现在都是CPU都是多核心的，所以存在两个线程同时运行，出现两个窗口同时出售同一张票这种不符合逻辑的情况

**解决方法：同步锁解决，[Synchronized](https://github.com/nullWolf007/Java/blob/master/Synchronized.md)**
> 线程安全(也就是同步)，必然以时间为代价，导致运行速度下降

## Lock接口
* 替代synchronized,避免synchronized里面出现异常，无法释放锁的情况
* Lock比synchronized更强大
```java
Lock l = ... ;
l.lock();
try{
	..
}finally{
	//无论如何都会释放锁
	l.unlock();
}
```
* **实现类ReentrantLock**
```java
Lock lock = new ReentrantLock()；
lock.lock();
//代码
lock.unlock();
```

## 死锁
* 当线程任务中出现了多个同步(锁)时，如果同步中嵌套了其他的同步，就会容易引发一种现象：程序无限等待，这种现象就叫做死锁
* 针对的时synchronized，线程进入同步获取锁，出去同步的时候才会释放锁
<img src="https://github.com/nullWolf007/Java/blob/master/Image/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86.JPG"/>

* 死锁的代码实现
```java
package demo02;

public class LockA {
	//保证唯一性
	private LockA() {
		
	}
	
	//外部类不能new 只能调用静态对象LockA
	public final static LockA locka = new LockA();
}
```
```java
package demo02;

public class LockB {
	private LockB() {

	}

	public final static LockB lockb= new LockB(); 
}
```
```java
package demo02;

public class DeadLock implements Runnable{

	private int i = 0;
	
	@Override
	public void run() {
		// TODO Auto-generated method stub
		while(true) {
			if(i%2==0) {
				//先进入A同步，再进入B同步
				synchronized (LockA.locka) {
					System.out.println("偶数进入A");
					synchronized (LockB.lockb) {
						System.out.println("偶数进入B");
					}
				}
			}else {
				//先进入B同步，再进入A同步
				synchronized (LockB.lockb) {
					System.out.println("奇数进入B");
					synchronized (LockA.locka) {
						System.out.println("奇数进入A");
					}
				}
			}
			i++;
		}
		
	}

}
```
```java
package demo02;

public class DeadLockDemo {
	public static void main(String[] args) {
		DeadLock dead = new DeadLock();
		Thread t0 = new Thread(dead);
		Thread t1 = new Thread(dead);
		t0.start();
		t1.start();
	}
}
```

## 线程等待与唤醒
### 常用方法
* wait()
* notify()
* notifyAll()
### 案例
<img src="https://github.com/nullWolf007/Java/blob/master/Image/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1.JPG" />





