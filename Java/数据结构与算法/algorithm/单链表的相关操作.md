# 单链表的相关操作

```java
public class Jike {
	public static void main(String[] args) {
		ListNode listNode = new ListNode(0);
		ListNode curr = listNode;
		for (int i = 1; i < 5; i++) {
			curr.next = new ListNode(i);
			curr = curr.next;
		}
		printAll(reverseKGroup(listNode, 2));
	}

	// 链表以2为基数反转
	public static ListNode swapPairs(ListNode head) {
		if (head == null) {
			return head;
		}
		if (head != null && null == head.next) {
			return head;
		}
		ListNode slow = head;
		ListNode fast = head;
		fast = fast.next;
		ListNode real = new ListNode(fast.val);
		ListNode returnNode = real;
		returnNode.next = new ListNode(slow.val);
		returnNode = returnNode.next;

		while (slow != null && fast != null && fast.next != null && fast.next.next != null) {
			fast = fast.next.next;
			slow = slow.next.next;

			ListNode front = new ListNode(fast.val);
			ListNode behind = new ListNode(slow.val);

			returnNode.next = front;
			returnNode = returnNode.next;
			returnNode.next = behind;
			returnNode = returnNode.next;
		}

		if (fast != null && fast.next != null) {
			returnNode.next = fast.next;
		}

		return real;

	}

	// 链表以2为基数反转 递归版
	public static ListNode swapPairs1(ListNode head) {
		if ((head == null) || (head.next == null))
			return head;
		ListNode n = head.next;
		head.next = swapPairs(head.next.next);
		n.next = head;
		return n;
	}

	// 链表以k为基数反转  拿到k的单链表 进行单链表反转 再合并
	public static ListNode reverseKGroup(ListNode head, int k) {
		ListNode curr = head;
		ListNode real = curr;

		ListNode returnNode = null;
		ListNode node = null;

		int count = 0;
		while (curr != null && count < k) {
			curr = curr.next;
			count++;
		}
		if (count == k) {
			if (node == null) {
				node = reverseK(real, k);
				returnNode = node;
			} else {
				node.next = reverseK(real, k);
			}
			while (node.next != null) {
				node = node.next;
			}
			node.next = reverseKGroup(curr, k);
		} else {
			return head;
		}
		return returnNode;
	}

	//合并k个链表
	// 合并多个链表
	public static ListNode mergeKLists(ListNode[] lists) {
		return merage(0, lists.length - 1, lists);
	}
	

	public static ListNode merage(int start, int end, ListNode[] lists) {
		if (start == end) {
			return lists[start];
		}

		if (start < end) {
			int middle = (start + end) / 2;
			ListNode node1 = merage(start, middle, lists);
			ListNode node2 = merage(middle + 1, end, lists);
			return merageSort(node1, node2);
		} else {
			return null;
		}
	}
	
	//删除指定位置的节点

	// 删除倒数第k个节点
	public static ListNode deleteKNode(ListNode list, int k) {
		ListNode fast = list;
		int i = 1;
		while (i < k && fast != null) {
			fast = fast.next;
			i++;
		}
		if (fast == null) {
			return list;
		}
		ListNode slow = list;
		ListNode prep = null;
		while (fast.next != null) {
			fast = fast.next;
			prep = slow;
			slow = slow.next;
		}

		if (prep == null) {
			list = list.next;
		} else {
			prep.next = prep.next.next;
		}
		return list;
	}
	
	//获取中间节点

	// 求中间节点的值
	public static int middleNode(ListNode list) {
		ListNode slow = list;
		ListNode fast = list;
		while (fast.next != null && fast.next.next != null) {
			fast = fast.next.next;
			slow = slow.next;
		}
		return slow.val;
	}
	
	//合并两个有序链表 递归

	// 有序链表两个的合并 递归版本
	public static ListNode merageSort(ListNode list1, ListNode list2) {
		if (list1 == null) {
			return list2;
		}
		if (list2 == null) {
			return list1;
		}
		if (list1.val < list2.val) {
			list1.next = merageSort(list1.next, list2);
			return list1;
		} else {
			list2.next = merageSort(list1, list2.next);
			return list2;
		}
	}
	
	//合并两个有序链表

	// 有序链表的合并
	public static ListNode merageSort1(ListNode list1, ListNode list2) {
		ListNode merge = null;
		if (list1.val < list2.val) {
			merge = createNode(list1.val);
			list1 = list1.next;
		} else {
			merge = createNode(list2.val);
			list2 = list2.next;
		}
		ListNode curr = merge;
		while (list1 != null && list2 != null) {
			ListNode node;
			if (list1.val < list2.val) {
				node = createNode(list1.val);
				list1 = list1.next;
			} else {
				node = createNode(list2.val);
				list2 = list2.next;
			}

			curr.next = node;
			curr = curr.next;
		}

		if (list1 != null) {
			curr.next = list1;
		}

		if (list2 != null) {
			curr.next = list2;
		}
		return merge;
	}
	
	//检查是否存在环

	// 检测环 追击相遇法
	public static boolean checkCircle(ListNode list) {
		if (list == null)
			return false;
		ListNode fast = list.next.next;
		ListNode slow = list.next;
		while (fast != null && fast.next != null) {
			fast = fast.next.next;
			slow = slow.next;
			if (slow == fast)
				return true;
		}
		return false;
	}
	
	//单链表全部反转

	// 单链表反转
	public static ListNode reverse(ListNode list) {
		ListNode curr = list;
		ListNode prep = null;

		// 思路：每次选一个元素放prep中，然后curr去除一个元素，然后把curr的第一个元素指向prep，即实现反转
		while (curr != null) {
			ListNode next = curr.next;
			curr.next = prep;
			prep = curr;
			curr = next;
		}

		return prep;
	}
	

	// 单链表指定长度反转 
	public static ListNode reverseK(ListNode list, int k) {
		ListNode curr = list;
		ListNode prep = null;

		// 思路：每次选一个元素放prep中，然后curr去除一个元素，然后把curr的第一个元素指向prep，即实现反转
		int count = 0;
		while (count < k && curr != null) {
			ListNode next = curr.next;
			curr.next = prep;
			prep = curr;
			curr = next;
			count++;
		}

		return prep;
	}

	// 打印链表
	public static void printAll(ListNode list) {
		ListNode p = list;
		while (p != null) {
			System.out.print(p.val + " ");
			p = p.next;
		}
		System.out.println();
	}

	// 创建节点
	public static ListNode createNode(int value) {
		return new ListNode(value, null);
	}

	public static class ListNode {
		private int val;
		private ListNode next;

		public ListNode(int val, ListNode next) {
			this.val = val;
			this.next = next;
		}

		public ListNode(int val) {
			this.val = val;
			this.next = null;
		}

	}
}
```

