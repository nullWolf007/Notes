# 正则表达式

## 元字符(特殊字符)
<table>
  <tr>
    <td>表示法</td>
    <td>描述</td>
    <td>示例</td>
  </tr>
  <tr>
    <td>符号</td>
  </tr>
  <tr>
    <td>re1|re2</td>
    <td>匹配正则表达式re1或者re2</td>
    <td>foo|bar</td>
  </tr>
  <tr>
    <td>.</td>
    <td>匹配一个任何字符（除了\n外）</td>
    <td>b.b</td>
  </tr>
  <tr>
    <td>^</td>
    <td>匹配字符串起始部分</td>
    <td>^Dear</td>
  </tr>
  <tr>
    <td>$</td>
    <td>匹配字符串终止部分</td>
    <td>sh$</td>
  </tr>
  <tr>
    <td>*</td>
    <td>匹配0次或者多次前面出现的正则表达式</td>
    <td>[A-Za-z0-9]*</td>
  </tr>
  <tr>
    <td>+</td>
    <td>匹配1次或者多次前面出现的正则表达式</td>
    <td>[A-Z]+</td>
  </tr>
  <tr>
    <td>?</td>
    <td>匹配0次或者1次前面出现的正则表达式</td>
    <td>foo?</td>
  </tr>
  <tr>
    <td>{N}</td>
    <td>匹配N次前面出现的正则表达式</td>
    <td>[0-9]{3}</td>
  </tr>
  <tr>
    <td>{M,N}</td>
    <td>匹配M~N次前面出现的正则表达式</td>
    <td>[0-9]{5,9}</td>
  </tr>
  <tr>
    <td>[...]</td>
    <td>匹配来自字符集的任意单一字符</td>
    <td>[aeiou]</td>
  </tr>
  <tr>
    <td>[...x-y...]</td>
    <td>匹配x-y范围中的任意单一字符</td>
    <td>[a-z0-9]</td>
  </tr>
  <tr>
    <td>[^...]</td>
    <td>不匹配此字符集中出现的任何一个字符，包括某一范围的字符</td>
    <td>[^0-9]</td>
  </tr>
  <tr>
    <td>(...)</td>
    <td>匹配封闭的正则表达式，然后另存为子组</td>
    <td>([0-9]{3})?</td>
  </tr>
  <tr>
    <td>特殊字符</td>
  </tr>
  <tr>
    <td>\d</td>
    <td>匹配任何十进制数字，与[0-9]一致(\D恰好相反，匹配任何非十进制数字)</td>
    <td>data\d+</td>
  </tr>
  <tr>
    <td>\w</td>
    <td>匹配任何字母数字字符，与[A-Za-z0-9]相同(与\W相反)</td>
    <td>\w+</td>
  </tr>
  <tr>
    <td>\s</td>
    <td>匹配任何空格字符，与[\n\t\r\v\f]相同(与\S相反)</td>
    <td>of\sthe</td>
  </tr>
  <tr>
    <td>\b</td>
    <td>匹配任何单词边界，(与\B相反)</td>
    <td>\bThe\b</td>
  </tr>
  <tr>
    <td>\N</td>
    <td>匹配已保存的子组N</td>
    <td></td>
  </tr>
  <tr>
    <td>\c</td>
    <td>逐字匹配任何特殊字符c</td>
    <td>\*</td>
  </tr>
  <tr>
    <td>\A(\Z)</td>
    <td>匹配字符串的起始(结束)</td>
    <td>\ADear</td>
  </tr>
  <tr>
    <td>扩展表示法</td>
  </tr>
  <tr>
    <td>(?iLmsux)</td>
    <td>在正则表达式中嵌入一个或多个特殊标记的参数</td>
  </tr>
  <tr>
    <td>(?:...)</td>
    <td>表示一个匹配不用保存的分组</td>
  </tr>
  <tr>
    <td>(?P&lt;name&gt;..)</td>
    <td>像一个仅有name标识而不是数字ID标识的正则分组匹配</td>
  </tr>
  <tr>
    <td>(?P=name)</td>
    <td>在同一字符串中匹配由(?P&lt;name)分组的之前文本</td>
  </tr>
  <tr>
    <td>(?#...)</td>
    <td>表示注释，所有内容都被忽略</td>
  </tr>
  <tr>
    <td>(?=...)</td>
    <td>匹配条件是如果...出现在之后的位置，而不使用输入字符串；称为正向前视断言</td>
  </tr>
  <tr>
    <td>(?！...)</td>
    <td>匹配条件是如果...不出现在之后的位置，而不使用输入字符串；称为负向前视断言</td>
  </tr>
  <tr>
    <td>(?&lt;=...)</td>
    <td>匹配条件是如果...出现在之前的位置，而不使用输入字符串；称为正向后视断言</td>
  </tr>
  <tr>
    <td>(?&lt;!...)</td>
    <td>匹配条件是如果...不出现在之前的位置，而不使用输入字符串；称为正向后视断言</td>
  </tr>
  <tr>
    <td>(?(id/name)Y|N)</td>
    <td>如果分组所提供的id或者name存在，就返回正则表达式的条件匹配Y,如果不存在，就返回N；|N是可选项</td>
  </tr>
</table>

## 实例
<table>
  <tr>
    <td>正则表达式模式</td>
    <td>匹配的字符串</td>
  </tr>
  <tr>
    <td>\Bthe</td>
    <td>任何包含但并不以the作为起始的字符串</td>
  </tr>
  <tr>
    <td>[“-a]</td>
    <td>在一个ASCII系统中，所有字符都位于两者之间，即34~97之间</td>
  </tr>
  <tr>
    <td>&lt;/?[^&gt;]+&gt;</td>
    <td>匹配全部有效的(和无效的)HTML标签</td>
  </tr>
  <tr>
    <td>(?:\w+\.)*</td>
    <td>以句点作为结尾的字符串，例如geogle.但是这些匹配不会保存下来供后续的使用和数据检索</td>
  </tr>
  <tr>
    <td>(?#comment)</td>
    <td>此处并不做匹配，只是作为注释</td>
  </tr>
  <tr>
    <td>(?=.com)</td>
    <td>如果一个字符串后面跟着.com才做匹配操作，并不使用任何目标字符串</td>
  </tr>
  <tr>
    <td>(?!.com)</td>
    <td>如果一个字符串后面不是跟着.net才做匹配操作=</td>
  </tr>
  <tr>
    <td>(?&lt;=800-)</td>
    <td>如果字符串之前为800-才做匹配，假定位电话号码，同样，并不使用任何输入字符串</td>
  </tr>
  <tr>
    <td>(?&lt;!192\.168\.)</td>
    <td>如果一个字符串之前不是192.168.才做匹配操作，假定用于过滤掉一组C类IP地址</td>
  </tr>
  <tr>
    <td>(?(1)y|x)</td>
    <td>如果一个匹配组1(\1)存在，就与有匹配，否则就与x匹配</td>
  </tr>
</table>

## re模块
### 主要的几个方法
* compile()
* match()
```java
如果匹配成功，返回匹配对象；否则返回None
要求：起始位置匹配
在第二个参数中找到满足第一个参数要求的子字符串
```
* search()
```java
如果匹配成功，返回匹配对象；否则返回None
要求：任意位置
在第二个参数中找到满足第一个参数要求的子字符串。第一个参数是正则表达式
```
* group()
```java
以普通方式显示所有的匹配部分，也像数组一样可以group(1)取各个匹配的子组，下标从1开始
```
* groups()
```java
获取全部子组，用小括号包裹的才叫子组
```
* findall()
```java
总是返回一个列表；没有匹配的话返回一个空列表
```
* finditer()
```text
在匹配对象中迭代，迭代器.next().group()
```
* sub()和subn()
```text
两个都返回替换后的字符串，但是subn()还返回一个表示替换总数的数字
```
* split()
```text

```
