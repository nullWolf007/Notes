# 二叉树的相关操作

```java
public class tree {
	public static Node tree;

	public static void main(String[] args) {
		tree = new Node(8);
		insertNode(5, tree);
		insertNode(7, tree);
		insertNode(4, tree);
		insertNode(9, tree);
		insertNode(1, tree);

		printTree(tree);

		deleteNode(tree, 9);

		System.out.println("删除后的：");
		printTree(tree);
	}

	/*
	 * 遍历输出树 中序遍历 从小到大
	 */
	public static void printTree(Node tree) {
		if (null == tree) {
			return;
		}
		printTree(tree.left);
		System.out.println(tree.data);
		printTree(tree.right);

	}

	/**
	 * 判断数据是否存在于树中
	 * 
	 * @param tree
	 * @return
	 */
	public static boolean isExist(Node tree, int data) {
		Node p = tree;
		while (p != null) {
			if (p.data < data) {
				p = p.right;
			} else if (p.data > data) {
				p = p.left;
			} else {
				return true;
			}
		}
		return false;
	}

	/*
	 * 插入数据 到 树中
	 */
	public static void insertNode(int data, Node tree) {
		if (tree == null) {
			tree = new Node(data);
			return;
		}

		Node p = tree;
		while (p != null) {
			if (p.data < data) {// 数据大 右子树
				if (p.right == null) {
					p.right = new Node(data);
					return;
				} else {
					p = p.right;
				}
			} else {// 数据小 左子树
				if (p.left == null) {
					p.left = new Node(data);
					return;
				} else {
					p = p.left;
				}
			}
		}
	}

	/**
	 * 对二叉树进行删除
	 * 
	 * @param tree
	 * @param data
	 */
	public static Node deleteNode(Node tree, int data) {
		if (!isExist(tree, data)) {
			return tree;
		}
		Node p = tree;
		Node pp = null;// 记录p的父结点
		while (p != null && p.data != data) {
			pp = p;
			if (p.data < data) {
				p = p.right;
			} else {
				p = p.left;
			}
		}
		if (p == null) {
			return null;// 沒有找到需要刪除的节点
		}
		if (p.left != null && p.right != null) {// 被刪除的节点 有两个子结点 则找到右子树的最小节点 进行替换
			Node minP = p;
			minP = minP.right;
			Node minPP = p;
			int flag = 0;// 判断为left还是right
			while (minP.left != null) {
				flag = 1;
				minPP = minP;
				minP = minP.left;
			}
			// 把最小节点的数据赋给p
			p.data = minP.data;
			if (flag == 0) {// 表示删除右节点
				minPP.right = null;// 删除最小的节点
			} else {
				minPP.left = null;// 删除最小的节点
			}
		} else if (p.left == null && p.right == null) {// 被刪除的节点没有子节点
			if (pp.data < p.data) {
				pp.right = null;
			} else {
				pp.left = null;
			}
		} else {// 只有左节点或者右节点
			if (p.left != null) {// 存在左节点
				pp.left = p.left;
			} else {// 存在右节点
				pp.right = p.right;
			}
		}
		return tree;
	}

	public static class Node {
		private int data;
		private Node left;
		private Node right;

		public Node(int data) {
			this.data = data;
		}
	}
}
```

