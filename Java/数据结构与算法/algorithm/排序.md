[TOC]

# 排序

## 常见的排序方法

### 一、插入排序

* 定义：插入排序重复地将新的元素插入到一个排好序地子线性表中，直到整个线性表排好序。

* 先把第一个元素当作数组，然后取第二个元素，进行比较插入到数组中。然后把前两个元素当作数组，取出第三个元素插入到数组中，插入的时候从后往前遍历，方便后移。以此类推。

* 时间按复杂度O(n^2)

* 实例

  ```java
  private static int[] sortUpArray(int[] array) {
  	for (int i = 1; i < array.length; i++) {//遍历
  		int currentElement = array[i];
  		int k;
  		for (k = i-1; k >= 0 && currentElement < array[k]; k--) {//从后向前查询
  			array[k + 1] = array[k];//满足条件  后移
  		}
  		array[k+1] = currentElement;//插入元素
  	}
  	return array;
  }
  ```

### 二、冒泡排序

* 定义：冒泡排序算法多次遍历数组，在每次遍历中连续比较相邻的元素，如果元素没有按照顺序排列，则互换他们的值

* 每次遍历拿到最大值放在最后，array.lenght-1次遍历就可以得到有序数组

* 时间复杂度O(n^2)

* 实例

  ```java
  private static int[] guluguluArray(int[] array) {
  	for (int i = 1; i < array.length; i++) {// 数组遍历
  		for (int j = 0; j < array.length - i; j++) {
  			if (array[j + 1] < array[j]) {
  				int ele = array[j];
  				array[j] = array[j + 1];
  				array[j + 1] = ele;
  			}
  		}
  	}
  	return array;
  }
  ```


### 三、归并排序

* 归并排序算法将数组分为两半，对每部分递归地应用归并排序。再两部分都排好序后，对他们进行归并。

* 时间复杂度O(nlogn)

* 采用递归思想，把数组递归分成两半，分到最小数组元素个数为一，然后再一直依次合并。合并的时候两个数组都是有序的。

* 实例

  ```java
  	private static int[] mergeSort(int[] list) {
  		if (list.length > 1) {
  			// 左半部分数组
  			int leftLength = list.length / 2;
  			int[] leftList = new int[leftLength];
  			System.arraycopy(list, 0, leftList, 0, leftLength);
  			// 递归调用
  			mergeSort(leftList);
  
  			// 右半部分数组
  			int rightLength = list.length - leftLength;
  			int[] rightList = new int[rightLength];
  			System.arraycopy(list, leftLength, rightList, 0, rightLength);
  			// 递归调用
  			mergeSort(rightList);
  
  			//合并数组
  			merge(leftList, rightList, list);
  		}
  		return list;
  	}                            
  
  	public static void merge(int[] leftList, int[] rightList, int[] list) {
  		int leftIndex = 0;
  		int rightIndex = 0;
  		int index = 0;
  		//把左右数组进行比较 较小地依次放入数组中  因为是merge过 所以左右数组都是升序排列地
  		while (leftIndex < leftList.length && rightIndex < rightList.length) {
  			//如果左数组值比较小 左边索引增一 右边索引不变 ，如果左边较小，反之
  			if (leftList[leftIndex] < rightList[rightIndex]) {
  				list[index++] = leftList[leftIndex++];
  			} else {
  				list[index++] = rightList[rightIndex++];
  			}
  		}
  		//把没有放入list的元素  进行放入
  		while (leftIndex < leftList.length) {
  			list[index++] = leftList[leftIndex++];
  		}
  		while (rightIndex < rightList.length) {
  			list[index++] = rightList[rightIndex++];
  		}
  	}
  ```

### 四、快速排序

* 定义：在数组中选择一个成为主元(pivot)的元素，将数组分为两部分，使得第一部分中的所有元素都小于或等于主元，而第二部分中的所有元素都大于主元。对第一部分第二部分递归的执行快速排序算法。

* 时间复杂度O(nlogn)

* 采用递归思想，通过主元分成两部分，一部分大于主元，一部分小于主元。然后对这两部分分别得到对应的主元，再进行比较，以此类推。

* 实例

  ```java
  	public static int[] quickSort(int[] list, int first, int last) {
  		if (first < last) {
  			int index = quick(list, first, last);
  			quickSort(list, first, index - 1);
  			quickSort(list, index + 1, last);
  		}
  		return list;
  	}
  
  	public static int quick(int[] list, int first, int last) {
  		int low = first + 1;
  		int high = last;
  		int pivot = list[first];// 主元
  		// 思路：从后往前找比主元小的 从前往后找比主元大的 并且前索引小于后索引
  		// 存在一对，此时交换两者位置
  		// 如果不存在一对，只存在单一，则索引会重合在一点上，与主元比较一下即可
  		// 把主元和后索引进行交换
  		while (low < high) {
  			while (low < high && list[low] <= pivot) {
  				low++;
  			}
  			while (low < high && list[high] > pivot) {
  				high--;
  			}
  			if (low < high) {
  				int temp = list[high];
  				list[high] = list[low];
  				list[low] = temp;
  			}
  		}
  
  		while (high > first && list[high] > pivot) {
  			high--;
  		}
  
  		if (high > first) {
  			int temp = list[high];
  			list[high] = list[first];
  			list[first] = temp;
  		}
  		return high;
  	}
  ```


### 五、堆排序

* 定义：堆排序使用的是二叉堆。它首先将所有的元素添加到一个堆上，然后不断移除最大的元素以获得一个排好序的线性表。

* 二叉堆：形状属性---完全二叉树      堆属性---每个结点大于或等于它的任意一个孩子

* 堆的存储：可以用数组进行存储。对于位置i处的结点，它的左子结点在位置2i+1处，它的右子结点2i+2处，而他的父结点在位置(i-1)/2处

* 添加一个新的结点：

  ```java
  将最后一个结点作为当前结点；
  while(当前结点大于它的父结点){
  	将当前结点和它的父结点交换；
  	现在当前结点往上面进了一个层次；
  }
  ```

* 删除根结点

  ```java
  用最后一个结点替换根节点；
  让根结点成为当前结点；
  while(当前结点具有子结点并且当前结点小于它的子结点){
  	将当前结点和它的较大子结点交换；
  	现在当前结点往下面退了一个层次；
  }
  ```

* Heap类